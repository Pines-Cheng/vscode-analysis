(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{215:function(e,t,s){e.exports=s.p+"assets/img/vscode-architecture.246227f5.jpeg"},216:function(e,t,s){e.exports=s.p+"assets/img/vscode-process.e445e292.png"},235:function(e,t,s){"use strict";s.r(t);var v=s(0),a=Object(v.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"vscode架构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vscode架构"}},[e._v("#")]),e._v(" VSCode架构")]),e._v(" "),v("p",[e._v("VSCode中包含主进程，渲染进程，同时因为VSCode提供了插件的扩展能力，又出于安全稳定性的考虑，图中又多了一个Extension Host，其实这个Extension Host也是一个独立的进程，用于运行我们的插件代码。并且同渲染进程一样，彼此都是独立互不影响的。Extension Host Process暴露了一些VSCode的API供插件开发者去使用。\n"),v("img",{attrs:{src:s(215),alt:"vscode-architecture"}})]),e._v(" "),v("h2",{attrs:{id:"vscode的进程结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vscode的进程结构"}},[e._v("#")]),e._v(" VSCode的进程结构")]),e._v(" "),v("p",[e._v("VSCode采用多进程架构，启动后主要由下面几个进程：")]),e._v(" "),v("ul",[v("li",[e._v("后台进程")]),e._v(" "),v("li",[e._v("编辑器窗口 - 由后台进程启动，也是多进程架构\n"),v("ul",[v("li",[e._v("HTML编写的UI\n"),v("ul",[v("li",[e._v("ActivityBar")]),e._v(" "),v("li",[e._v("SideBar")]),e._v(" "),v("li",[e._v("Panel")]),e._v(" "),v("li",[e._v("Editor")]),e._v(" "),v("li",[e._v("StatusBar")])])]),e._v(" "),v("li",[e._v("Nodejs异步IO\n"),v("ul",[v("li",[e._v("FileService")]),e._v(" "),v("li",[e._v("ConfigurationService")])])]),e._v(" "),v("li",[e._v("插件宿主进程\n"),v("ul",[v("li",[e._v("插件实例\n"),v("ul",[v("li",[e._v("插件子进程 - 如TS语言服务")])])]),e._v(" "),v("li",[e._v("插件实例")]),e._v(" "),v("li",[e._v("插件实例")])])]),e._v(" "),v("li",[e._v("Debug进程")]),e._v(" "),v("li",[e._v("Search进程")])])])]),e._v(" "),v("p",[v("img",{attrs:{src:s(216),alt:"vscode-process"}})]),e._v(" "),v("h3",{attrs:{id:"后台进程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#后台进程"}},[e._v("#")]),e._v(" 后台进程")]),e._v(" "),v("p",[e._v("后台进程是 VSCode 的入口，主要负责管理编辑器生命周期，进程间通信，自动更新，菜单管理等。")]),e._v(" "),v("p",[e._v("我们启动 VSCode 的时候，后台进程会首先启动，读取各种配置信息和历史记录，然后将这些信息和主窗口 UI 的 HTML 主文件路径整合成一个 URL，启动一个浏览器窗口来显示编辑器的 UI。后台进程会一直关注 UI 进程的状态，当所有 UI 进程被关闭的时候，整个编辑器退出。")]),e._v(" "),v("p",[e._v("此外后台进程还会开启一个本地的 Socket，当有新的 VSCode 进程启动的时候，会尝试连接这个 Socket，并将启动的参数信息传递给它，由已经存在的 VSCode 来执行相关的动作，这样能够保证 VSCode 的唯一性，避免出现多开文件夹带来的问题。")]),e._v(" "),v("h3",{attrs:{id:"编辑器窗口"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#编辑器窗口"}},[e._v("#")]),e._v(" 编辑器窗口")]),e._v(" "),v("p",[e._v("编辑器窗口进程负责整个 UI 的展示。也就是我们所见的部分。UI 全部用 HTML 编写没有太多需要介绍的部分。")]),e._v(" "),v("h3",{attrs:{id:"nodejs异步io"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#nodejs异步io"}},[e._v("#")]),e._v(" Nodejs异步IO")]),e._v(" "),v("p",[e._v("项目文件的读取和保存由主进程的 NodeJS API 完成，因为全部是异步操作，即便有比较大的文件，也不会对 UI 造成阻塞。IO 跟 UI 在一个进程，并采用异步操作，在保证 IO 性能的基础上也保证了 UI 的响应速度。")]),e._v(" "),v("h3",{attrs:{id:"插件进程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#插件进程"}},[e._v("#")]),e._v(" 插件进程")]),e._v(" "),v("p",[e._v("每一个 UI 窗口会启动一个 NodeJS 子进程作为插件的宿主进程。所有的插件会共同运行在这个进程中。这样设计最主要的目的就是避免复杂的插件系统阻塞 UI 的响应。但是将插件放在一个单独进程也有很明显的缺点，因为是一个单独的进程，而不是 UI 进程，所以没有办法直接访问 DOM 树，想要实时高效的改变 UI 变得很难，在 VSCode 的扩展体系中几乎没有对 UI 进行扩展的 API。")]),e._v(" "),v("h3",{attrs:{id:"debug进程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#debug进程"}},[e._v("#")]),e._v(" Debug进程")]),e._v(" "),v("p",[e._v("Debugger 插件跟普通的插件有一点区别，它不运行在插件进程中，而是在每次 debug 的时候由UI单独新开一个进程。")]),e._v(" "),v("h3",{attrs:{id:"搜索进程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#搜索进程"}},[e._v("#")]),e._v(" 搜索进程")]),e._v(" "),v("p",[e._v("搜索是一个十分耗时的任务，VSCode 也使用的单独的进程来实现这个功能，保证主窗口的效率。将耗时的任务分到多个进程中，有效的保证了主进程的响应速度。")])])}),[],!1,null,null,null);t.default=a.exports}}]);